# 第五章 死锁

## 第一节 死锁的产生

### 一、死锁的定义

​		指在多道程序系统中，一组进程中的每一个进程均无限期的等待被该组进程中的了另一个进程所占用且永远不会释放的资源。

​		处于死锁状态的进程称为死锁进程。

### 二、死锁产生的原因

#### 1、资源的概念

1. 永久性资源(可重用资源)

   如内存、外部设备、处理器等硬件资源。

   各种数据文件、表格、共享程序代码等软件资源。

2. 临时性资源(消耗性资源)

   指由某个进程产生、只为另一个进程使用一次或经过短暂时间后便不在使用的资源。

   如I/O和时钟中断信号、同步信号、消息等。

#### 2、产生死锁的原因

1. 竞争资源

   系统在资源分配时出现失误、进程间对资源相互争夺而造成僵局。

2. 进程推进顺序不合理

#####  1、申请不同类资源产生死锁

1. 进程`P1`和`P2`在运行中使用输入、输出设备，假定系统中只有一台输入设备和一台输出设备，则进程`P1`和`P2`可有如下形势：

![](F:\自考\操作系统\img\2020-05-19_162528.jpg)

如果进程交替执行，如下：

* `P1`：申请一台输入设备
* `P2`：申请一台输出设备
* `P1`：申请一台输出设备
* `P2`：申请一台输入设备

![](F:\自考\操作系统\img\2020-05-19_162836.jpg)

##### 2、申请同类资源产生死锁

假设有一类可重用资源R，如内存，它包含m个页面，由n个进程`P1`、`P2`，...，`Pn(2<=m<=n)`共享。假定每个进程按下述顺序依次申请和释放页面：

1. 申请一个页面
2. 申请一个页面
3. 释放一个页面
4. 释放一个页面

n=3, m=2的情况

![](F:\自考\操作系统\img\2020-05-19_163640.jpg)

##### 3、P、V操作使用不当产生的死锁

​		对于第四章 生产者---消费者问题，如果把`P(mutex)`放在`P(empty)`和`P(Full)`之前，就会产生死锁

考虑当：

* empty=0， full = n 的情况

  第一种情况：假设生产者进程占有处理器，此时，执行完`P(mutex)`,在执行`P(empty)`时，生产者进程阻塞，让出处理器，消费者进程执行`P(mutex)`也会阻塞，此时产生死锁。

* empty=n， full = 0 的情况

  第二种情况：假设消费者进程占有处理器，此时，执行完`P(mutex)`,在执行`P(full)`时，消费者进程阻塞，让出处理器，生产者进程执行`P(mutex)`也会阻塞，此时产生死锁。

##### 4、对临时性资源的使用不加限制产生死锁

​		在进程通信时使用的信件可以看做是一种临时性资源，如果对信件的发送和接收不加限制，则可能引起死锁

​		比如，进程`P1`等待进程`P3`的信件`S3`，`S3`到来后再向进程`P2`发送信件`S1`，`P2`又要等待`P1`的信件`S1`到来后在向`P3`发送信件`S2`，`P3`进程也要等待进程`P2`的信件`S2`到来后才能发送信件`S3`。

|                                                 |                                                 |
| ----------------------------------------------- | ----------------------------------------------- |
| ![](F:\自考\操作系统\img\2020-05-19_170628.jpg) | ![](F:\自考\操作系统\img\2020-05-19_171000.jpg) |

##### 5、对临时性资源的使用不加限制产生死锁 --不产生死锁

|                                                 |                                                 |
| ----------------------------------------------- | ----------------------------------------------- |
| ![](F:\自考\操作系统\img\2020-05-19_171232.jpg) | ![](F:\自考\操作系统\img\2020-05-19_171000.jpg) |

### 三、产生死锁的四个必要条件

对于永久性资源，产生死锁的四个必要条件：

- 互斥条件
- 不可剥夺条件
- 请求和保持条件
- 循环等待条件

### 四、解决死锁的方法

- 预防死锁
- 避免死锁
- 检测与解除死锁
- 忽略死锁

## 第二节 死锁预防

### 一、死锁预防的概念

* 死锁预防

  是指在任何系统操作前(如分配资源、调度进程等)，事先评估系统的可能情况，严格采取措施，使得产生死锁的四个必要条件不成立

* 基本思想

  防患于未然

* 具体做法

  破坏产生死锁的四个必要条件之一

### 二、静态资源分配策略

* 分配原则：

  一个进程在申请新资源的要求得不到满足时，便处于等待状态，而处于等待状态的进程的全部资源可以被剥夺。

  两个策略：

  * 破坏不可剥夺条件
  * 破坏请求和保持条件

#### 1、破坏不可剥夺条件

两种方法：

* 若一个进程已占用了某些资源，又要申请新的资源，在得不到新资源的同时释放原有资源，然后等待。
* 若一个进程申请新资源，首先系统检查该资源是否可用，如果可用则分配，否则从其他等待进程剥夺资源分配给该进程，如果没有等待进程占有该资源，该进程必须等待，在等待过程中，资源也可能被剥夺。

#### 2、破坏请求和保持条件

方法：

​		每个进程必须在开始执行前就申请它所需要的全部资源，仅当系统能满足进程的资源请求且把资源一次性分配给进程后，该进程才能开始执行。

### 三、资源有序分配法

- 策略：

​		破坏循环等待条件

- 方法：

​		对系统所有资源类型进行线性排序，并赋予不同的序号。进程申请资源时，必须严格按照资源编号的顺序进行。即一个进程先得到编号小的资源，才能申请编号大的资源。释放资源时，次序相反。

- 一般原则：

​		较为紧缺、稀少的资源的编号较大。

- 破坏循环等待条件

​		比如，令输入及的序号为1，打印机的序号为2，磁带机为3，磁盘为4。所有进程对资源是请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“循环等待”条件。